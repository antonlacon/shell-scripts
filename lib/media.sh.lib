# media.sh.lib v20120609
#
# Copyright 2011-2012: Ian Leonard <antonlacon@gmail.com>
#
# This file is media.sh.lib.
#
# media.sh.lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# media.sh.lib is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with media.sh.lib. If not, see <http://www.gnu.org/licenses/>.
#
# Common multimedia related functions to assist in shell scripting
#
# Exit Codes:
# 1: reserved for caller
# 2: audio related
# 3: video related
# 4: general failure
#
# Functions Provided:
# CreateAudioPipe
# CreateVideoPipeAspectShifted
# CreateVideoPipeStraightThrough
# DestroyPipe
# EncodeAudio_FlacFlac
# EncodeAudio_MP4AAC
# EncodeAudio_OggVorbis
# GatherMediaInfo
# IncreaseAudioVolume
# QueryVideoHeight
# QueryVideoWidth
# TestForAudio
# TestForVideo

# CreateAudioPipe(input file)
# Opens a named pipe and fills it with the audio output of a file
# Requirements: ffmpeg or avconv or mplayer, mkfifo, common.sh.lib
# See also: DestroyPipe
#
# Relies on invoker to set the following VARIABLES:
# TEMP_DIR

CreateAudioPipe() {
	# fixme: implement QueryAudioChannels?
	AUDIO_CHANNELS=2

	AUDIO_PIPE=$( tmp_random_name )
	echo "CreateAudioPipe named pipe is: "$AUDIO_PIPE

	# Test for existence of audiopipe already
	if [ -e "${TEMP_DIR}"/"${AUDIO_PIPE}" ]; then
		die "Abort: Named pipe file already exists." "2"
	else
		mkfifo "${TEMP_DIR}"/"${AUDIO_PIPE}" || die "failed to create named pipe" "2"
	fi

	# Make a named pipe and fill it with transcoder's output in WAV format.
	# Select an audio transcoder to output WAV: (ffmpeg, libav, mplayer)
	if command -v ffmpeg > /dev/null; then
		ffmpeg -i "${1}" -acodec pcm_s16le -ac "${AUDIO_CHANNELS}" -f wav -y "${TEMP_DIR}"/"${AUDIO_PIPE}" &>/dev/null &
	elif command -v avconv > /dev/null; then
		avconv -i "${1}" -acodec pcm_s16le -ac "${AUDIO_CHANNELS}" -f wav -y "${TEMP_DIR}"/"${AUDIO_PIPE}" &>/dev/null &
	elif command -v mplayer > /dev/null; then
		mplayer -really-quiet -nocorrect-pts -vo null -vc null -ao pcm:waveheader:fast:file="${TEMP_DIR}"/"${AUDIO_PIPE}" "${1}" &
	else
		die "Abort: No supported audio transcoder detected." "2"
	fi

	if [ $? -ne 0 ]; then
		die "Abort: Failed to fill named pipe." "2"
	fi
}

# CreateVideoPipeAspectShifted(input file)
# Creates a named pipe that transcoded video to X standard while converting display aspect ratio to 4/3, while maintaining original video aspect ratio
# Requirements: mplayer, mkfifo
#
# Relies on invoker to set the following VARIABLES:
# DEVICE_ASPECT_RATIO
# DEVICE_HEIGHT
# TEMP_DIR
# DEVICE_WIDTH

CreateVideoPipeAspectShifted() {
	VIDEO_PIPE=$( tmp_random_name )
	echo "CreateVideoPipe named pipe is: "${VIDEO_PIPE}

	# Test for existence of videopipe already
	if [ -e "${TEMP_DIR}"/${VIDEO_PIPE} ]; then
		die "Abort: Named pipe file already exists." "3"
	else
	        mkfifo "${TEMP_DIR}"/${VIDEO_PIPE} || die "failed to create named pipe" "3"
	fi

	if command -v mplayer > /dev/null; then
	        # mplayer's vf filter chain resizes to DEVICE_ASPECT_RATIO of player while maintaining original aspect ratio of the video
	        mplayer -really-quiet -nosub -nosound -benchmark -sws 9 -vf dsize="$DEVICE_WIDTH":"$DEVICE_HEIGHT",scale=0:0,expand="$DEVICE_WIDTH":"$DEVICE_HEIGHT",dsize="${DEVICE_ASPECT_RATIO}" -vo yuv4mpeg:file="${TEMP_DIR}"/${VIDEO_PIPE} "${1}" &
	else
		die "Abort: No supported video transcoder detected." "3"
	fi

	if [ $? -ne 0 ]; then
		die "Abort: Failed to fill named pipe." "3"
	fi
}

# CreateVideoPipeStraightThrough(input file)
# Creates a named pipe for transcoded video to X standard
# Requirements: mplayer, mkfifo
#
# Relies on invoker to set the following VARIABLES:
# TEMP_DIR

CreateVideoPipeStraightThrough() {
	VIDEO_PIPE=$( tmp_random_name )
	echo "CreateVideoPipe named pipe is: "${VIDEO_PIPE}

	# Test for existence of videopipe already
	if [ -e "${TEMP_DIR}"/${VIDEO_PIPE} ]; then
		die "Abort: Named pipe file already exists." "3"
	else
	        mkfifo "${TEMP_DIR}"/${VIDEO_PIPE} || die "failed to create named pipe" "3"
	fi

	if command -v mplayer > /dev/null; then
	        mplayer -really-quiet -nosub -nosound -benchmark -sws 9 -vo yuv4mpeg:file="${TEMP_DIR}"/${VIDEO_PIPE} "${1}" &
	else
		die "Abort: No video transcoder detected." "3"
	fi

	if [ $? -ne 0 ]; then
		die "Abort: Failed to fill named pipe." "3"
	fi
}

# DetectVideoCrop
# Sample 5% of video frames to estimate crop settings. Utilizes 99% confidence interval of final result.

# DestroyPipe(argument) 
# Delete named pipes created by CreateAudipPipe or CreateVideoPipe*
#
# Relies on invoker to set the following VARIABLES:
# TEMP_DIR

DestroyPipe() {
	case "${1}" in
	audio)
		local NAMED_PIPE="${AUDIO_PIPE}"
		;;
	video)
		local NAMED_PIPE="${VIDEO_PIPE}"
		;;
	*)
		die "Abort: Unknown usgae of DestroyPipe" "4"
		;;
	esac

	if [ -e "${TEMP_DIR}"/"${NAMED_PIPE}" ]; then
		rm "${TEMP_DIR}"/"${NAMED_PIPE}" || die "Abort: Failed to destroy named pipe." "4"
	fi
}

# EncodeAudio_FlacFlac(input file)
# Convert input file to Flac in the native Flac container
# Flac has no quality settings, only compressoin levels. Always use the best.
# Requirements: ffmpeg or avconv or flac
#
# Relies on invoker to set following VARIABLES:
# TEMP_DIR

EncodeAudio_FlacFlac() {
	# reference flac encoder needs coaxing to work with named pipes, and is picky about input formats - make it last.
	if command -v ffmpeg -o command -v avconv > /dev/null; then
		if command -v ffmpeg; then
			local AUDIO_ENCODER="ffmpeg"
		else
			local AUDIO_ENCODER="avconv"
		fi

		FLAC_SUPPORT=$( "${AUDIO_ENCODER}" -codecs | grep -c "FLAC (Free Lossless Audio Codec)" )
		if [ $FLAC_SUPPORT -eq 0 ]; then
			die "Abort: ""${AUDIO_ENCODER}"" does not appear to support flac."
		fi

		CreateAudioPipe "${1}"
		"${AUDIO_ENCODER}" -i "${TEMP_DIR}"/"${AUDIO_PIPE}" -acodec flac -compression_level 8 "${TEMP_DIR}"/audio.flac || die "${AUDIO_ENCODER}"" failed" "2"
		DestroyPipe audio	
	elif command -v flac > /dev/null; then
# uncomment if time is found to make this work with named pipes
#		flac --best "${TEMP_DIR}"/"${AUDIO_PIPE}" -o "${TEMP_DIR}"/audio.flac || die "Abort: flac failed." "2"
		flac --best "${INPUT}" -o "${TEMP_DIR}"/audio.flac || die "Abort: flac failed." "2"
	fi
}

# EncodeAudio_MP4AAC(input file)
# Converts input file to AAC and puts into an mp4 container.
# Requirements: neroAacEnc or faac, common.sh.lib
#
# Relies on invoker to set following VARIABLES:
# TEMP_DIR
#
# For audio files, the following must also be set:
# AVCONV_AAC_AUDIO_QUALITY_STANDALONE
# FAAC_AAC_AUDIO_QUALITY_STANDALONE
# FFMPEG_AAC_AUDIO_QUALITY_STANDALONE
# NEROAACENC_AAC_AUDIO_QUALITY_STANDALONE
#
# For video files, the following must also be set:
# AVCONV_AAC_AUDIO_QUALITY_VIDEO
# HAS_VIDEO
# FAAC_AAC_AUDIO_QUALITY_VIDEO
# FFMPEG_AAC_AUDIO_QUALITY_VIDEO
# NEROAACENC_AAC_AUDIO_QUALITY_VIDEO

EncodeAudio_MP4AAC() {
	# Test for audio encoders and set quality variable accordingly
	# Priority Order (descending): neroAacEnc, faac, ffmpeg, avconv
	# Build a named pipe and fill it with uncompressed WAV. Have the audio encoder read from the pipe

	if command -v neroAacEnc > /dev/null; then
		if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
			local AUDIO_QUALITY="${NEROAACENC_AUDIO_QUALITY_VIDEO}"
		else
			local AUDIO_QUALITY="${NEROAACENC_AUDIO_QUALITY_STANDALONE}"
		fi

		CreateAudioPipe "${1}"
		neroAacEnc -ignorelength -lc -q "${AUDIO_QUALITY}" -if "${TEMP_DIR}"/"${AUDIO_PIPE}" -of "${TEMP_DIR}"/audio.mp4 || die "neroAacEnc failed" "2"
	elif command -v faac > /dev/null; then
		if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
			local AUDIO_QUALITY="${FAAC_AUDIO_QUALITY_VIDEO}"
		else
			local AUDIO_QUALITY="${FAAC_AUDIO_QUALITY_STANDALONE}"
		fi

		CreateAudioPipe "${1}"
		faac -q "${AUDIO_QUALITY}" -o "${TEMP_DIR}"/audio.mp4 "${TEMP_DIR}"/"${AUDIO_PIPE}" || die "faac failed" "2"
	elif command -v ffmpeg -o command -v avconv > /dev/null; then
		if command -v ffmpeg; then
			local AUDIO_ENCODER="ffmpeg"
			if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
				local AUDIO_QUALITY="${FFMPEG_AAC_AUDIO_QUALITY_VIDEO}"
			else
				local AUDIO_QUALITY="${FFMPEG_VORBIS_AUDIO_QUALITY_STANDALONE}"
			fi
		else
			local AUDIO_ENCODER="avconv"
			if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
				local AUDIO_QUALITY="${AVCONV_AAC_AUDIO_QUALITY_VIDEO}"
			else
				local AUDIO_QUALITY="${AVCONV_VORBIS_AUDIO_QUALITY_STANDALONE}"
			fi
		fi

		AAC_SUPPORT=$( "${AUDIO_ENCODER}" -codecs | grep -c "libfaac AAC \(Advanced Audio Codec\)" )
		if [ $AAC_SUPPORT -eq 0 ]; then
			die "Abort: ""${AUDIO_ENCODER}"" does not appear to support aac encoding."
		fi

		CreateAudioPipe "${1}"
		# Uses libfaac as FFmpeg's aac encoder is experimental
		"${AUDIO_ENCODER}" -i "${TEMP_DIR}"/"${AUDIO_PIPE}" -acodec aac -aq "${AUDIO_QUALITY}" "${TEMP_DIR}"/audio.mp4 || die "${AUDIO_ENCODER}"" failed" "2"
	else
		die "Abort: Failed to locate neroAacEnc, faac, ffmpeg or avconv in your \$PATH." "2"
	fi

	DestroyPipe audio
}

# EncodeAudio_OggVorbis(input file)
# Converts input file to Vorbis and puts into an ogg container.
# Requirements: vorbis-tools or ffmpeg or avconv, common.sh.lib
#
# Relies on invoker to set following VARIABLES:
# TEMP_DIR
#
# For audio files, the following must also be set:
# OGGENC_VORBIS_AUDIO_QUALITY_STANDALONE
# FFMPEG_VORBIS_AUDIO_QUALITY_STANDALONE
# AVCONV_VORBIS_AUDIO_QUALITY_STANDALONE
#
# For video files, the following must also be set:
# HAS_VIDEO
# OGGENC_VORBIS_AUDIO_QUALITY_VIDEO
# FFMPEG_VORBIS_AUDIO_QUALITY_VIDEO
# AVCONV_VORBIS_AUDIO_QUALITY_VIDEO

EncodeAudio_OggVorbis() {
	if command -v oggenc > /dev/null; then
		if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
			local AUDIO_QUALITY="${OGGENC_VORBIS_AUDIO_QUALITY_VIDEO}"
		else
			local AUDIO_QUALITY="${OGGENC_VORBIS_AUDIO_QUALITY_STANDALONE}"
		fi

		CreateAudioPipe "${1}"
		oggenc -q "${AUDIO_QUALITY}" --ignorelength "${TEMP_DIR}"/"${AUDIO_PIPE}" -o "${TEMP_DIR}"/audio.ogg || die "oggenc failed" "2"
	elif command -v ffmpeg -o command -v avconv > /dev/null; then
		if command -v ffmpeg; then
			local AUDIO_ENCODER="ffmpeg"
			if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
				local AUDIO_QUALITY="${FFMPEG_VORBIS_AUDIO_QUALITY_VIDEO}"
			else
				local AUDIO_QUALITY="${FFMPEG_VORBIS_AUDIO_QUALITY_STANDALONE}"
			fi
		else
			local AUDIO_ENCODER="avconv"
			if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
				local AUDIO_QUALITY="${AVCONV_VORBIS_AUDIO_QUALITY_VIDEO}"
			else
				local AUDIO_QUALITY="${AVCONV_VORBIS_AUDIO_QUALITY_STANDALONE}"
			fi
		fi
		CreateAudioPipe "${1}"
		#NOTE: FFmpeg's vorbis implementation is experimental - using their libvorbis hook instead.
		"${AUDIO_ENCODER}" -i "${TEMP_DIR}"/"${AUDIO_PIPE}" -acodec libvorbis -aq "${AUDIO_QUALITY}" "${TEMP_DIR}"/audio.ogg || die "${AUDIO_ENCODER}"" failed" "2"
	else
		die "Abort: Failed to locate oggenc, ffmpeg or avconv in your \$PATH." "2"
	fi
	DestroyPipe audio
}

# IncreaseAudioVolume (integer amount, input file, output file)
# Increases audio volume. Default is 256 (maintain current)
# Must be chained from CreateAudioPipe
#
# Integer values > 256 will increase volume.
# Integer values < 256 will decrease volume.
#
# Requires:
# TEMP_DIR
# INPUT

IncreaseAudioVolume() {
	local MEDIA_PIPE="${TEMP_DIR}"/"${AUDIO_PIPE}"
	local LOUDER_AUDIO_PIPE=$( tmp_random_name )

	# Test for existence of audiopipe already
	if [ -e "${TEMP_DIR}"/"${LOUDER_AUDIO_PIPE}" ]; then
		die "Abort: Named pipe file already exists." "2"
	else
		mkfifo "${TEMP_DIR}"/"${LOUDER_AUDIO_PIPE}" || die "failed to create named pipe" "2"
	fi

	ffmpeg -i "${MEDIA_PIPE}" -acodec pcm_s16le -ac 2 -vol 512 -f wav -y "${TEMP_DIR}"/"${LOUDER_AUDIO_PIPE}" || die "failed while increasing volume" "2"

	DestroyPipe audio
	AUDIO_PIPE="${LOUDER_AUDIO_PIPE}"
	echo "IncreaseAudioVolume Pipe is: "$AUDIO_PIPE
}

# GatherMediaInfo
# Store the output of a media query tool (midentify, ffprobe, etc) and set the tool to use for querying.

# need to add the avconv tools

GatherMediaInfo() {
	if command -v ffprobe > /dev/null; then
		QUERY_MEDIA_TOOL=ffprobe
		MEDIA_INFO=$( ffprobe -show_streams "${INPUT}" 2>/dev/null )
	elif command -v midentify > /dev/null; then
		QUERY_MEDIA_TOOL=midentify
		MEDIA_INFO=$( midentify "${INPUT}" )
	elif command -v mplayer > /dev/null; then
		QUERY_MEDIA_TOOL=midentify
	# Adapted from midentify.sh by Tobias Diedrich <ranma+mplayer@tdiedrich.de>. License: GNU GPL
		MEDIA_INFO=$( mplayer -noconfig all -cache-min 0 -vo null -ao null -frames 0 -identify "${INPUT}" 2>/dev/null | sed -ne '/^ID_/ {
                         s/[]()|&;<>`'"'"'\\!$" []/\\&/g;p
                        }')
	# End adaptation of midentify.sh
	elif command -v ffmpeg > /dev/null; then
		QUERY_MEDIA_TOOL=ffmpeg
		MEDIA_INFO=$( ffmpeg -i "${INPUT}" 2>&1 )
	else
		die "Abort: No known program found to find media stream information." "4"
	fi
}

# NormalizeAudio

# QueryAudioChannels(input file)
# Inspect input file for the number of audio channels
# ASSUMES ONE AUDIO STREAM
# Uses: mplayer or FFprobe or ...

QueryAudioChannels() {
	local AUDIO_CHANNELS=$( ffprobe -show_streams "${1}" | grep "channels=" | sed 's/channels\=//' )
	echo "${AUDIO_CHANNELS}"
}

# QueryAudioStreamMap(input file)

# QueryVideoHeight
# Query a video file to determine its display height
#
# MUST RUN: GatherMediaInfo

QueryVideoHeight() {
	case "${QUERY_MEDIA_TOOL}" in
		ffprobe)
			local VIDEO_HEIGHT=$( echo "${MEDIA_INFO}" | grep height | cut -d '=' -f 2 )
			;;
		midentify)
			local VIDEO_HEIGHT=$( echo "${MEDIA_INFO}" | grep ID_VIDEO_HEIGHT | cut -d '=' -f 2)
			;;
		ffmpeg)
			local VIDEO_HEIGHT=$( echo "${MEDIA_INFO}" | grep Sream | grep Video | cut -d ',' -f 3 | tr " " - | cut -d '-' -f 2 | cut -d 'x' -f 2 )
			;;
		*)
			die "Abort: Failed finding video height." "3"
			;;
	esac
	echo "${VIDEO_HEIGHT}"
}

# QueryVideoWidth
# Query a video file to determine its display width
#
# MUST RUN: GatherMediaInfo

QueryVideoWidth() {
	case "${QUERY_MEDIA_TOOL}" in
		ffprobe)
			local VIDEO_WIDTH=$( echo "${MEDIA_INFO}" | grep width | cut -d '=' -f 2 )
			;;
		midentify)
			local VIDEO_WIDTH=$( echo "${MEDIA_INFO}" | grep ID_VIDEO_WIDTH | cut -d '=' -f 2)
			;;
		ffmpeg)
			local VIDEO_WIDTH=$( echo "${MEDIA_INFO}" | grep Sream | grep Video | cut -d ',' -f 3 | tr " " - | cut -d '-' -f 2 | cut -d 'x' -f 1 )
			;;
		*)
			die "Abort: Failed finding video width." "3"
			;;
	esac
	echo "${VIDEO_WIDTH}"
}

# QueryVideoAspectRatio
# Query a video file to determine its display aspect ratio

# TestForAudio(input file)
# Check a file for the presence of an audio stream
# Uses: ffprobe, midentify, mplayer, or ffmpeg
#
# MUST RUN: GatherMediaInfo

# Needs avconv programs

TestForAudio() {
	case "${QUERY_MEDIA_TOOL}" in
		ffprobe) 
			local AUDIO_TEST=$( echo "${MEDIA_INFO}" | grep -c codec_type=audio )
			;;
		midentify)
			local AUDIO_TEST=$( echo "${MEDIA_INFO}" | grep -c ID_AUDIO )
			;;
		ffmpeg)
			local AUDIO_TEST=$( echo "${MEDIA_INFO}" | grep -c Audio )
			;;
		*)
			die "Abort: No known program found to detect audio streams." "2"
			;;
	esac
	echo "${AUDIO_TEST}"
}

# TestForVideo(input file)
# Check a file for the presence of a video stream
# Uses: ffprobe, midentify, mplayer, or ffmpeg
#
# MUST RUN: GatherMediaInfo

# Needs avconv programs

TestForVideo() {
	case "${QUERY_MEDIA_TOOL}" in
		ffprobe) 
			local VIDEO_TEST=$( echo "${MEDIA_INFO}" | grep -c codec_type=video )
			;;
		midentify)
			local VIDEO_TEST=$( echo "${MEDIA_INFO}" | grep -c ID_VIDEO )
			;;
		ffmpeg)
			local VIDEO_TEST=$( echo "${MEDIA_INFO}" | grep -c Video )
			;;
		*)
			die "Abort: No known program found to detect video streams." "3"
			;;
	esac
	echo "${VIDEO_TEST}"
}
