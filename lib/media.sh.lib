# media.sh.lib v20120429
#
# Copyright 2011-2012: Ian Leonard <antonlacon@gmail.com>
#
# This file is media.sh.lib.
#
# media.sh.lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# media.sh.lib is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with media.sh.lib. If not, see <http://www.gnu.org/licenses/>.
#
# Common multimedia related functions to assist in shell scripting
#
# Exit Codes:
# 1: reserved for invoker
# 2: audio related
# 3: video related
#
# Functions Provided:
# CreateAudioPipe
# CreateVideoPipeAspectShifted
# CreateVideoPipeStraightThrough
# DestroyAudioPipe
# DestroyVideoPipe
# EncodeAudio_FlacFlac
# EncodeAudio_MP4AAC
# EncodeAudio_OggVorbis
# IncreaseAudioVolume
# 

# CreateAudioPipe(input file)
# Opens a named pipe and fills it with the audio output of a file
# Requirements: ffmpeg or avconv or mplayer, mkfifo, common.sh.lib
# See also: DestroyAudioPipe
#
# Relies on invoker to set the following VARIABLES:
# TEMP_DIR

CreateAudioPipe() {
	# fixme: implement QueryAudioChannels?
	AUDIO_CHANNELS=2

	AUDIO_PIPE=$( tmp_random_name )
	echo "CreateAudioPipe audio pipe is: "$AUDIO_PIPE

	# Test for existence of audiopipe already
	if [ -e "${TEMP_DIR}"/"${AUDIO_PIPE}" ]; then
		die "Abort: Named pipe file already exists." "2"
	else
		mkfifo "${TEMP_DIR}"/"${AUDIO_PIPE}" || die "failed to create named pipe" "2"
	fi

	# Make a named pipe and fill it with transcoder's output in WAV format.
	# Select an audio transcoder to output WAV: (ffmpeg, libav, mplayer)
	if command -v ffmpeg > /dev/null; then
		ffmpeg -i "${1}" -acodec pcm_s16le -ac "${AUDIO_CHANNELS}" -f wav -y "${TEMP_DIR}"/"${AUDIO_PIPE}" &>/dev/null &
	elif command -v avconv > /dev/null; then
		avconv -i "${1}" -acodec pcm_s16le -ac "${AUDIO_CHANNELS}" -f wav -y "${TEMP_DIR}"/"${AUDIO_PIPE}" &>/dev/null &
	elif command -v mplayer > /dev/null; then
		mplayer -really-quiet -nocorrect-pts -vo null -vc null -ao pcm:waveheader:fast:file="${TEMP_DIR}"/"${AUDIO_PIPE}" "${1}" &
	else
		die "Abort: No supported audio transcoder detected." "2"
	fi

	if [ $? -ne 0 ]; then
		die "Abort: Failed to fill named pipe." "2"
	fi
}

# CreateVideoPipeAspectShifted(input file)
# Creates a named pipe that transcoded video to X standard while converting display aspect ratio to 4/3, while maintaining original video aspect ratio
# Requirements: mplayer, mkfifo
#
# Relies on invoker to set the following VARIABLES:
# ASPECT_RATIO
# HEIGHT
# TEMP_DIR
# WIDTH

CreateVideoPipeAspectShifted() {

	VIDEO_PIPE=$( tmp_random_name )
	echo "CreateVideoPipe audio pipe is: "${VIDEO_PIPE}

	# Test for existence of videopipe already
	if [ -e "${TEMP_DIR}"/${VIDEO_PIPE} ]; then
		die "Abort: Named pipe file already exists." "3"
	fi

	if command -v mplayer > /dev/null; then
	        mkfifo "${TEMP_DIR}"/${VIDEO_PIPE}
	        # mplayer's vf filter chain resizes to ASPECT_RATIO of player while maintaining original aspect ratio of the video
	        mplayer -really-quiet -nosub -nosound -benchmark -sws 9 -vf dsize="$WIDTH":"$HEIGHT",scale=0:0,expand="$WIDTH":"$HEIGHT",dsize="${ASPECT_RATIO}" -vo yuv4mpeg:file="${TEMP_DIR}"/${VIDEO_PIPE} "${1}" &
	else
		die "Abort: No supported video transcoder detected." "3"
	fi

	if [ $? -ne 0 ]; then
		die "Abort: Failed to fill named pipe." "3"
	fi
}

# CreateVideoPipeStraightThrough(input file)
# Creates a named pipe for transcoded video to X standard
# Requirements: mplayer, mkfifo
#
# Relies on invoker to set the following VARIABLES:
# TEMP_DIR

CreateVideoPipeStraightThrough() {

	VIDEO_PIPE=$( tmp_random_name )
	echo "CreateVideoPipe audio pipe is: "${VIDEO_PIPE}

	# Test for existence of videopipe already
	if [ -e "${TEMP_DIR}"/${VIDEO_PIPE} ]; then
		die "Abort: Named pipe file already exists." "3"
	fi

	if command -v mplayer > /dev/null; then
	        mkfifo "${TEMP_DIR}"/${VIDEO_PIPE}
	        mplayer -really-quiet -nosub -nosound -benchmark -sws 9 -vo yuv4mpeg:file="${TEMP_DIR}"/${VIDEO_PIPE} "${1}" &
	else
		die "Abort: No video transcoder detected." "3"
	fi

	if [ $? -ne 0 ]; then
		die "Abort: Failed to fill named pipe." "3"
	fi
}

# DestroyAudioPipe()
# Deletes named pipe created by CreateAudioPipe
# See also: CreateAudioPipe
#
# Relies on invoker to set the following VARIABLES:
# TEMP_DIR

DestroyAudioPipe() {
	if [ -e "${TEMP_DIR}"/"${AUDIO_PIPE}" ]; then
		rm "${TEMP_DIR}"/"${AUDIO_PIPE}" || die "Abort: Failed to destroy named pipe." "2"
	fi
}

# DestroyVideoPipe()
# Deletes named pipe created by CreateVideoPipeStraightThrough or CreateVideoPipeAspectLocked
# See also: CreateVideoPipeStraightThrough and CreateVideoPipeAspectShifted
#
# Relies on invoker to set the following VARIABLES:
# TEMP_DIR

DestroyVideoPipe() {
	if [ -e "${TEMP_DIR}"/${VIDEO_PIPE} ]; then
	        rm "${TEMP_DIR}"/${VIDEO_PIPE} || die "Abort: Failed to destroy named pipe." "3"
	fi
}

# EncodeAudio_FlacFlac(input file)
# Convert input file to Flac in the native Flac container
# Flac has no quality settings, only compressoin levels. Always use the best.
# Requirements: ffmpeg or avconv or flac
#
# Relies on invoker to set following VARIABLES:
# TEMP_DIR

EncodeAudio_FlacFlac() {
	
	# reference flac encoder needs coaxing to work with named pipes, and is picky about input formats - make it last.
	if command -v ffmpeg -o command -v avconv > /dev/null; then
		if command -v ffmpeg; then
			local AUDIO_ENCODER="ffmpeg"
		else
			local AUDIO_ENCODER="avconv"
		fi

		FLAC_SUPPORT=$( "${AUDIO_ENCODER}" -codecs | grep -c "FLAC (Free Lossless Audio Codec)" )
		if [ $FLAC_SUPPORT -eq 0 ]; then
			die "Abort: ""${AUDIO_ENCODER}"" does not appear to support flac."
		fi

		CreateAudioPipe "${1}"
		"${AUDIO_ENCODER}" -i "${TEMP_DIR}"/"${AUDIO_PIPE}" -acodec flac -compression_level 8 "${TEMP_DIR}"/audio.flac || die "${AUDIO_ENCODER}"" failed" "2"
		DestroyAudioPipe	
	elif command -v flac > /dev/null; then
# uncomment if time is found to make this work with named pipes
#		flac --best "${TEMP_DIR}"/"${AUDIO_PIPE}" -o "${TEMP_DIR}"/audio.flac || die "Abort: flac failed." "2"
		flac --best "${INPUT}" -o "${TEMP_DIR}"/audio.flac || die "Abort: flac failed." "2"
	fi
}

# EncodeAudio_MP4AAC(input file)
# Converts input file to AAC and puts into an mp4 container.
# Requirements: neroAacEnc or faac, common.sh.lib
#
# Relies on invoker to set following VARIABLES:
# TEMP_DIR
#
# For audio files, the following must also be set:
# AVCONV_AAC_AUDIO_QUALITY_STANDALONE
# FAAC_AAC_AUDIO_QUALITY_STANDALONE
# FFMPEG_AAC_AUDIO_QUALITY_STANDALONE
# NEROAACENC_AAC_AUDIO_QUALITY_STANDALONE
#
# For video files, the following must also be set:
# AVCONV_AAC_AUDIO_QUALITY_VIDEO
# HAS_VIDEO
# FAAC_AAC_AUDIO_QUALITY_VIDEO
# FFMPEG_AAC_AUDIO_QUALITY_VIDEO
# NEROAACENC_AAC_AUDIO_QUALITY_VIDEO

EncodeAudio_MP4AAC() {
	# Test for audio encoders and set quality variable accordingly
	# Priority Order (descending): neroAacEnc, faac, ffmpeg, avconv
	# Build a named pipe and fill it with uncompressed WAV. Have the audio encoder read from the pipe

	if command -v neroAacEnc > /dev/null; then
		if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
			local AUDIO_QUALITY="${NEROAACENC_AUDIO_QUALITY_VIDEO}"
		else
			local AUDIO_QUALITY="${NEROAACENC_AUDIO_QUALITY_STANDALONE}"
		fi

		CreateAudioPipe "${1}"
		neroAacEnc -ignorelength -lc -q "${AUDIO_QUALITY}" -if "${TEMP_DIR}"/"${AUDIO_PIPE}" -of "${TEMP_DIR}"/audio.mp4 || die "neroAacEnc failed" "2"
	elif command -v faac > /dev/null; then
		if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
			local AUDIO_QUALITY="${FAAC_AUDIO_QUALITY_VIDEO}"
		else
			local AUDIO_QUALITY="${FAAC_AUDIO_QUALITY_STANDALONE}"
		fi

		CreateAudioPipe "${1}"
		faac -q "${AUDIO_QUALITY}" -o "${TEMP_DIR}"/audio.mp4 "${TEMP_DIR}"/"${AUDIO_PIPE}" || die "faac failed" "2"
	elif command -v ffmpeg -o command -v avconv > /dev/null; then
		if command -v ffmpeg; then
			local AUDIO_ENCODER="ffmpeg"
			if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
				local AUDIO_QUALITY="${FFMPEG_AAC_AUDIO_QUALITY_VIDEO}"
			else
				local AUDIO_QUALITY="${FFMPEG_VORBIS_AUDIO_QUALITY_STANDALONE}"
			fi
		else
			local AUDIO_ENCODER="avconv"
			if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
				local AUDIO_QUALITY="${AVCONV_AAC_AUDIO_QUALITY_VIDEO}"
			else
				local AUDIO_QUALITY="${AVCONV_VORBIS_AUDIO_QUALITY_STANDALONE}"
			fi
		fi

		AAC_SUPPORT=$( "${AUDIO_ENCODER}" -codecs | grep -c "libfaac AAC \(Advanced Audio Codec\)" )
		if [ $AAC_SUPPORT -eq 0 ]; then
			die "Abort: ""${AUDIO_ENCODER}"" does not appear to support aac encoding."
		fi

		CreateAudioPipe "${1}"
		# Uses libfaac as FFmpeg's aac encoder is experimental
		"${AUDIO_ENCODER}" -i "${TEMP_DIR}"/"${AUDIO_PIPE}" -acodec aac -aq "${AUDIO_QUALITY}" "${TEMP_DIR}"/audio.mp4 || die "${AUDIO_ENCODER}"" failed" "2"
	else
		die "Abort: Failed to locate neroAacEnc, faac, ffmpeg or avconv in your \$PATH." "2"
	fi

	DestroyAudioPipe
}

# EncodeAudio_OggVorbis(input file)
# Converts input file to Vorbis and puts into an ogg container.
# Requirements: vorbis-tools or ffmpeg or avconv, common.sh.lib
#
# Relies on invoker to set following VARIABLES:
# TEMP_DIR
#
# For audio files, the following must also be set:
# OGGENC_VORBIS_AUDIO_QUALITY_STANDALONE
# FFMPEG_VORBIS_AUDIO_QUALITY_STANDALONE
# AVCONV_VORBIS_AUDIO_QUALITY_STANDALONE
#
# For video files, the following must also be set:
# HAS_VIDEO
# OGGENC_VORBIS_AUDIO_QUALITY_VIDEO
# FFMPEG_VORBIS_AUDIO_QUALITY_VIDEO
# AVCONV_VORBIS_AUDIO_QUALITY_VIDEO


EncodeAudio_OggVorbis() {
	if command -v oggenc > /dev/null; then
		if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
			local AUDIO_QUALITY="${OGGENC_VORBIS_AUDIO_QUALITY_VIDEO}"
		else
			local AUDIO_QUALITY="${OGGENC_VORBIS_AUDIO_QUALITY_STANDALONE}"
		fi

		CreateAudioPipe "${1}"
		oggenc -q "${AUDIO_QUALITY}" --ignorelength "${TEMP_DIR}"/"${AUDIO_PIPE}" -o "${TEMP_DIR}"/audio.ogg || die "oggenc failed" "2"
	elif command -v ffmpeg -o command -v avconv > /dev/null; then
		if command -v ffmpeg; then
			local AUDIO_ENCODER="ffmpeg"
			if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
				local AUDIO_QUALITY="${FFMPEG_VORBIS_AUDIO_QUALITY_VIDEO}"
			else
				local AUDIO_QUALITY="${FFMPEG_VORBIS_AUDIO_QUALITY_STANDALONE}"
			fi
		else
			local AUDIO_ENCODER="avconv"
			if [ -n "${HAS_VIDEO}" ] && [ "${HAS_VIDEO}" -ge 1 ]; then
				local AUDIO_QUALITY="${AVCONV_VORBIS_AUDIO_QUALITY_VIDEO}"
			else
				local AUDIO_QUALITY="${AVCONV_VORBIS_AUDIO_QUALITY_STANDALONE}"
			fi
		fi
		CreateAudioPipe "${1}"
		#NOTE: FFmpeg's vorbis implementation is experimental - using their libvorbis hook instead.
		"${AUDIO_ENCODER}" -i "${TEMP_DIR}"/"${AUDIO_PIPE}" -acodec libvorbis -aq "${AUDIO_QUALITY}" "${TEMP_DIR}"/audio.ogg || die "${AUDIO_ENCODER}"" failed" "2"
	else
		die "Abort: Failed to locate oggenc, ffmpeg or avconv in your \$PATH." "2"
	fi
	DestroyAudioPipe
}

# IncreaseAudioVolume (integer amount, input file, output file)
# Increases audio volume. Default is 256 (maintain current)
# Must be chained from CreateAudioPipe
#
# Integer values > 256 will increase volume.
# Integer values < 256 will decrease volume.
#
# Requires:
# TEMP_DIR
# INPUT

IncreaseAudioVolume() {
	local MEDIA_PIPE="${TEMP_DIR}"/"${AUDIO_PIPE}"
	local LOUDER_AUDIO_PIPE=$( tmp_random_name )

	# Test for existence of audiopipe already
	if [ -e "${TEMP_DIR}"/"${LOUDER_AUDIO_PIPE}" ]; then
		die "Abort: Named pipe file already exists." "2"
	else
		mkfifo "${TEMP_DIR}"/"${LOUDER_AUDIO_PIPE}" || die "failed to create named pipe" "2"
	fi

	ffmpeg -i "${MEDIA_PIPE}" -acodec pcm_s16le -ac 2 -vol 512 -f wav -y "${TEMP_DIR}"/"${LOUDER_AUDIO_PIPE}" || die "failed while increasing volume" "2"

	DestroyAudioPipe
	AUDIO_PIPE="${LOUDER_AUDIO_PIPE}"
	echo "IncreaseAudioVolume Pipe is: "$AUDIO_PIPE
}

# NormalizeAudio

# have one giant query audio function that outputs to a /tmp file?
# then have separate functions that grep it

# QueryAudioChannels(input file)
# Inspect input file for the number of audio channels
# ASSUMES ONE AUDIO STREAM
# Uses: mplayer or FFprobe or ...

QueryAudioChannels() {
	local AUDIO_CHANNELS=$( ffprobe -show_streams "${1}" | grep "channels=" | sed 's/channels\=//' )
	return "${AUDIO_CHANNELS}"
}

# QueryAudioStreamMap(input file)

# TestForAudio(input file)

# TestForVideo(input file)
